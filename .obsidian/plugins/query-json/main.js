/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => QJSON
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/functions.ts
function parseQuery(query) {
  const parts = query.split(".");
  const parsed = parts.map((part) => {
    const multiFieldMatch = part.match(/^\{([^}]+)\}$/);
    if (multiFieldMatch && multiFieldMatch[1].includes(",")) {
      const fields = multiFieldMatch[1].split(",").map((f) => f.trim());
      return {
        type: "multiField",
        fields
      };
    }
    const filterMatch = part.match(/(\w*)\[(.*)\]/);
    if (filterMatch) {
      return {
        type: "filter",
        field: filterMatch[1] || null,
        condition: filterMatch[2]
      };
    }
    if (/^\d+$/.test(part)) {
      return {
        type: "index",
        index: parseInt(part)
      };
    }
    return {
      type: "field",
      name: part
    };
  });
  let first = true;
  for (const q of parsed) {
    if (first) {
      first = false;
    } else {
      if (q.type === "filter" && !q.field) {
        throw Error(`Filter without field: ${query}`);
      }
    }
  }
  return parsed;
}
function parseCondition(condition) {
  const logicalOperators = ["&&", "||"];
  let conditions = [];
  let operators = [];
  let currentCondition = condition;
  for (const operator of logicalOperators) {
    while (currentCondition.includes(operator)) {
      const operatorIndex = currentCondition.indexOf(operator);
      const leftPart = currentCondition.substring(0, operatorIndex).trim();
      if (conditions.length === 0) {
        conditions.push(parseSingleCondition(leftPart));
      }
      operators.push(operator);
      currentCondition = currentCondition.substring(operatorIndex + operator.length).trim();
    }
  }
  conditions.push(parseSingleCondition(currentCondition));
  return { conditions, operators };
}
function parseSingleCondition(condition) {
  const comparisonOperators = [">=", "<=", "==", ">", "<", "!=", "*"];
  for (let operator of comparisonOperators) {
    if (condition.includes(operator)) {
      const [key, value] = condition.split(operator).map((s) => s.trim());
      return { key, operator, value };
    }
  }
  throw new Error(`Invalid condition: ${condition}`);
}
function executeQuery(json, parsedQuery) {
  let result = json;
  for (let i = 0; i < parsedQuery.length; i++) {
    const part = parsedQuery[i];
    if (part.type === "field") {
      if (Array.isArray(result)) {
        result = result.map((item) => item[part.name]).filter((item) => item !== void 0);
      } else if (result && typeof result === "object") {
        result = result[part.name];
      }
    } else if (part.type === "index") {
      if (Array.isArray(result)) {
        result = result[part.index];
      } else {
        return void 0;
      }
    } else if (part.type === "multiField") {
      if (Array.isArray(result)) {
        result = result.map((item) => {
          const extracted = {};
          part.fields.forEach((field) => {
            if (item && item.hasOwnProperty(field)) {
              extracted[field] = item[field];
            }
          });
          return extracted;
        });
      } else if (result && typeof result === "object") {
        const extracted = {};
        part.fields.forEach((field) => {
          if (result.hasOwnProperty(field)) {
            extracted[field] = result[field];
          }
        });
        result = extracted;
      }
    } else if (part.type === "filter") {
      const { conditions, operators } = parseCondition(part.condition);
      let arrayToFilter = result;
      if (part.field) {
        arrayToFilter = result[part.field];
      }
      if (Array.isArray(arrayToFilter)) {
        result = arrayToFilter.filter((item) => {
          return evaluateConditions(item, conditions, operators);
        });
      }
    }
  }
  return result;
}
function evaluateConditions(item, conditions, operators) {
  if (conditions.length === 0) return true;
  let result = evaluateCondition(item, conditions[0]);
  for (let i = 0; i < operators.length; i++) {
    const operator = operators[i];
    const nextConditionResult = evaluateCondition(item, conditions[i + 1]);
    if (operator === "&&") {
      result = result && nextConditionResult;
    } else if (operator === "||") {
      result = result || nextConditionResult;
    }
  }
  return result;
}
function evaluateCondition(item, condition) {
  const { key, operator, value } = condition;
  const itemValue = item[key];
  switch (operator) {
    case "*":
      return true;
    case ">=":
      return Number(itemValue) >= Number(value);
    case "<=":
      return Number(itemValue) <= Number(value);
    case "==":
      return itemValue == value;
    case ">":
      return Number(itemValue) > Number(value);
    case "<":
      return Number(itemValue) < Number(value);
    case "!=":
      return itemValue != value;
    default:
      return false;
  }
}
function formatOutput(json) {
  if (typeof json === "string") {
    return json;
  } else {
    return JSON.stringify(json, null, 2);
  }
}
function getJSONPath(json, path) {
  if (path === "") return json;
  return path.split(".").reduce((acc, key) => acc[key], json);
}
function formatString(template, obj) {
  return template.replace(/{([^}]+)}/g, (match, name) => {
    return formatOutput(obj[name]);
  });
}

// src/main.ts
var QJSON = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.qjsonBlockCount = 0;
    this.countTimeout = null;
  }
  async onload() {
    this.statusBarItemEl = this.addStatusBarItem();
    this.statusBarItemEl.setText("");
    this.registerEvent(this.app.workspace.on("file-open", async (file) => {
      this.qjsonBlockCount = 0;
      if (file) {
        await this.countQjsonBlocks();
      } else {
        this.statusBarItemEl.setText("");
      }
    }));
    this.registerEvent(this.app.workspace.on("active-leaf-change", async () => {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        this.qjsonBlockCount = 0;
        await this.countQjsonBlocks();
      } else {
        this.statusBarItemEl.setText("");
      }
    }));
    this.registerEvent(this.app.workspace.on("editor-change", async (editor) => {
      if (this.countTimeout) {
        clearTimeout(this.countTimeout);
      }
      this.countTimeout = setTimeout(async () => {
        await this.countQjsonBlocks();
      }, 1e3);
    }));
    this.registerMarkdownCodeBlockProcessor("qjson", async (source, el) => {
      var _a;
      if (!source.includes("#qj-id:")) {
        new import_obsidian.Notice("No ID found");
        el.createEl("pre", { text: "No ID found" });
        return;
      }
      let id;
      id = source.match(/^#qj-id: (\d+)$/m);
      if (id) id = id[1];
      if (isNaN(parseInt(id))) {
        new import_obsidian.Notice("ID must be a number");
        el.createEl("pre", { text: "ID must be a number" });
        return;
      }
      let query;
      if (source.includes("#qj-query:")) {
        query = source.match(/^#qj-query: ([^\n\r]+)$/m);
        if (query) {
          query = query[1];
        } else {
          new import_obsidian.Notice("No query found");
          el.createEl("pre", { text: "No query found" });
          return;
        }
        let properties = app.metadataCache.getFileCache(this.app.workspace.getActiveFile());
        if (properties && properties.frontmatter) {
          for (const key in properties.frontmatter) {
            query = query.replace(new RegExp(`{this.${key}}`, "g"), properties.frontmatter[key]);
          }
        }
        console.log(query);
        query = parseQuery(query);
      }
      let format;
      let selectedFields;
      if (source.includes("#qj-format:")) {
        format = source.match(/^#qj-format: ([^\[\n\r ]+)[\t\f ]*(?:\[((?:[^\]\n\r=:,\"]*:(?:[^\]\n\r=:,\"]+|"[^\"]+")(?::[^\]\n\r=,]+)?(?:=[^\]\n\r,]+)?(?:,[^\n\r\w]*)?)+)\])?$/m);
        if (format) {
          if (format[2]) {
            const formats = format[2].split(/(?<=[^\]\n\r=:,\"]*:(?:[^\]\n\r=:,\"]+|"[^\"]+")(?::[^\]\n\r=,]+)?(?:=[^\]\n\r,]+)?)[\t\f ]*,/);
            selectedFields = formats.map((f) => {
              const fParts = f.match(/^([^\]\n\r=:,\"]*):(?:([^\]\n\r=:,\"]+)|"([^\"]+)")(?::([^\]\n\r=,]+))?(?:=([^\]\n\r,]+))?$/);
              const flags = fParts[1];
              const name = fParts[5] || null;
              const field = fParts[2] || null;
              const template = fParts[3] || null;
              const field2 = fParts[4] || null;
              return {
                header: flags.includes("h"),
                bold: flags.includes("b"),
                comma: flags.includes("c"),
                br: flags.includes("n"),
                link: flags.includes("l"),
                name,
                field,
                template,
                field2
              };
            });
            let first = true;
            for (const sf of selectedFields) {
              if (first) {
                first = false;
              } else {
                if (sf.header) {
                  new import_obsidian.Notice('Field format "header" is not in first position');
                  el.createEl("pre", { text: 'Field format "header" is not in first position' });
                  return;
                }
              }
              if (!sf.field && !sf.template) {
                new import_obsidian.Notice("Field format is missing field name");
                el.createEl("pre", { text: "Field format is missing field name" });
                return;
              }
              if (sf.link && !sf.field2) {
                new import_obsidian.Notice("Field format link is missing second field name");
                el.createEl("pre", { text: "Field format link is missing second field name" });
                return;
              }
              if (sf.template && !sf.name) {
                new import_obsidian.Notice("Field format with template must provide name");
                el.createEl("pre", { text: "Field format with template must provide name" });
                return;
              }
            }
          }
          format = format[1];
        } else {
          new import_obsidian.Notice("No format found");
          el.createEl("pre", { text: "No format found" });
          return;
        }
      }
      let desc;
      if (!source.includes("#qj-hide-id")) {
        try {
          desc = source.match(/^#qj-desc: ([^\n\r]+)$/m);
          desc = (_a = desc[1]) != null ? _a : "\xBB\xBB\xBB QJSON \xAB\xAB\xAB";
        } catch (e) {
          desc = "\xBB\xBB\xBB QJSON \xAB\xAB\xAB";
        }
        el.createEl("h3", { text: desc, cls: "centerQJtext" });
        el.createEl("h4", { text: "ID: " + id, cls: "centerQJtext" });
      }
      let showJson = "notHere";
      if (source.includes("#qj-show-json")) {
        showJson = "";
      }
      if (source.includes("#qj-file:")) {
        const file = source.match(/^#qj-file: ([^\n\r]+)$/m);
        if (file) {
          try {
            source = await this.app.vault.adapter.read(file[1]);
          } catch (e) {
            const filePath = this.app.workspace.getActiveFile().parent.path + "/";
            source = await this.app.vault.adapter.read(filePath + file[1]);
          }
        } else {
          new import_obsidian.Notice("No file given");
          el.createEl("pre", { text: "No file given" });
          return;
        }
      } else {
        source = source.replace(/^#qj-[a-z]+(: )?.*$/gm, "");
      }
      const json = JSON.parse(source);
      let result = json;
      let fieldResult;
      if (query) {
        result = executeQuery(json, query);
        fieldResult = query[query.length - 1].type === "field";
      } else {
        fieldResult = !Array.isArray(result);
      }
      if (!format || format === "json") {
        el.createEl("pre", { text: JSON.stringify(result, null, 2), cls: "QJSON-" + id + " cdQjson " + showJson });
      } else {
        if (fieldResult) {
          if (selectedFields) {
            new import_obsidian.Notice("Field queries currently ignore field formats");
          }
          if (format === "list") {
            const ul = el.createEl("ul");
            if (typeof result === "string") {
              ul.createEl("li", { text: result });
            } else if (Array.isArray(result)) {
              for (let i = 0; i < result.length; i++) {
                ul.createEl("li", { text: formatOutput(result[i]) });
              }
            } else if (typeof result === "object") {
              for (const key of result) {
                const tr = tbody.createEl("tr");
                tr.createEl("th", { text: key });
                tr.createEl("td", { text: formatOutput(result[key]) });
              }
            } else {
              new import_obsidian.Notice("unsupported object type");
            }
          } else if (format === "table") {
            const table = el.createEl("table");
            const tbody2 = table.createEl("tbody");
            if (typeof result === "string") {
              const tr = tbody2.createEl("tr");
              tr.createEl("td", { text: result });
            } else if (Array.isArray(result)) {
              for (let i = 0; i < result.length; i++) {
                const tr = tbody2.createEl("tr");
                tr.createEl("td", { text: formatOutput(result[i]) });
              }
            } else if (typeof result === "object") {
              for (const key of result) {
                const tr = tbody2.createEl("tr");
                tr.createEl("th", { text: key });
                tr.createEl("td", { text: formatOutput(result[key]) });
              }
            } else {
              new import_obsidian.Notice("unsupported object type");
            }
          } else if (format === "img") {
            if (typeof result === "string") {
              el.createEl("img", { attr: { src: result } });
            } else if (Array.isArray(result)) {
              let notString = false;
              for (let i = 0; i < result.length; i++) {
                if (typeof result[i] === "string") {
                  el.createEl("img", { attr: { src: result[i], width: 100, height: 100 } });
                } else {
                  notString = true;
                }
              }
              if (notString) {
                new import_obsidian.Notice("one or more entries could not be rendered");
              }
            } else {
              new import_obsidian.Notice('format "img" does not support objects');
            }
          }
        } else {
          if (!Array.isArray(result)) {
            new import_obsidian.Notice("Table & list can only be created from array");
            el.createEl("pre", { text: "Table & list can only be created from array" });
            return;
          }
          if (!selectedFields && result.length > 0) {
            if (Array.isArray(result[0]) || typeof result[0] !== "object") {
              result = result.map((e) => {
                return { entry: e };
              });
            }
            selectedFields = Object.entries(result[0]).map(([k, v], i) => {
              return {
                header: false,
                bold: false,
                comma: false,
                br: false,
                link: false,
                name: null,
                field: k,
                field2: null
              };
            });
          }
          let oEl;
          let titleNum = 1;
          if (format === "list") {
            if (selectedFields[0].header && selectedFields[0].name) {
              formatElement(el, selectedFields[0], null, selectedFields[0].name);
            }
            oEl = el.createEl("ul", { attr: { style: "list-style-position: outside;" } });
          } else if (format === "table") {
            const table = el.createEl("table");
            const thead = table.createEl("thead");
            oEl = table.createEl("tbody");
            const tr = thead.createEl("tr");
            for (const select of selectedFields) {
              const name = select.name || select.field;
              let td = tr.createEl("td");
              td.createEl("b", { text: name });
            }
          }
          let eEl;
          for (const entry of result) {
            if (format === "list") {
              let hEl = oEl.createEl("li");
              if (selectedFields[0].header) {
                formatElement(hEl, selectedFields[0], entry);
              } else {
                hEl.appendText("" + titleNum++);
              }
              eEl = hEl.createEl("lu", { attr: { style: "list-style-position: inside;" } });
            } else if (format === "table") {
              eEl = oEl.createEl("tr");
            }
            for (const select of selectedFields) {
              if (format === "list") {
                if (select.header) {
                  continue;
                }
                let fEl = eEl.createEl("li");
                if (select.name) {
                  fEl.appendText(select.name);
                } else {
                  fEl.appendText(select.field);
                }
                fEl.appendText(": ");
                formatElement(fEl, select, entry);
              } else if (format === "table") {
                let fEl;
                if (select.header) {
                  fEl = eEl.createEl("th");
                } else {
                  fEl = eEl.createEl("td");
                }
                formatElement(fEl, select, entry);
              }
            }
          }
        }
      }
      this.qjsonBlockCount++;
    });
    this.registerEvent(this.app.workspace.on("editor-change", async (editor) => {
      const cursor = editor.getCursor();
      const line = editor.getLine(cursor.line);
      const lastChar = line[line.length - 1];
      const match = line.match(/@(.+)>(.+)|@(.+)>/);
      if (!match) return;
      if (lastChar !== ";" && lastChar !== "." && lastChar !== ">" && lastChar !== "]") return;
      const id = match[1] || match[3];
      let path = "";
      if (match[2] !== void 0) {
        path = match[2].slice(0, -1).replace(/>/, "");
      }
      let json;
      if (!isNaN(parseInt(id)) && !id.includes(".json")) {
        const el = document.querySelector(".QJSON-" + id);
        if (!el) return;
        json = JSON.parse(el.textContent || "");
      } else {
        json = JSON.parse(await this.app.vault.adapter.read(id));
      }
      path = path.replace(/\*/g, "").replace(/\[\]/g, "");
      let value = getJSONPath(json, path);
      if (lastChar !== ";") {
        if (value !== void 0) {
          const notice = document.querySelector(".notice");
          if (notice) notice.remove();
          const keys = Object.keys(value);
          const keysAreNumbers = keys.every((key) => !isNaN(parseInt(key)));
          if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
            new import_obsidian.Notice(value.toString());
          } else if (keysAreNumbers) {
            new import_obsidian.Notice("Total Keys: " + (keys.length - 1));
          } else {
            new import_obsidian.Notice("Total Keys: " + keys.length + "\n____________\n" + keys.join("\n"));
          }
        }
      } else {
        if (line.includes("[*]")) {
          const temp_data = [];
          const arrayMatch = line.match(/(.+)\[\*\](?:\.(\w+))?/);
          if (arrayMatch) {
            const arrayKey = arrayMatch[1].slice(arrayMatch[1].indexOf(">") + 1);
            const property = arrayMatch[2];
            const arrayElements = getJSONPath(json, arrayKey);
            for (let i = 0; i < arrayElements.length; i++) {
              if (property) {
                temp_data.push(arrayElements[i][property]);
              } else {
                temp_data.push(arrayElements[i]);
              }
            }
          }
          value = temp_data;
        }
        const atIndex = line.indexOf("@");
        const replaceEnd = { line: cursor.line, ch: line.length };
        const stringValue = typeof value === "string" ? value : JSON.stringify(value);
        editor.replaceRange(stringValue, { line: cursor.line, ch: atIndex }, replaceEnd);
      }
    }));
  }
  async countQjsonBlocks() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      this.statusBarItemEl.setText("");
      return;
    }
    try {
      const content = await this.app.vault.read(activeFile);
      const qjsonBlockRegex = /```qjson[\s\S]*?#qj-id:\s*(\d+)/g;
      const matches = content.matchAll(qjsonBlockRegex);
      const ids = /* @__PURE__ */ new Set();
      const duplicateIds = /* @__PURE__ */ new Set();
      for (const match of matches) {
        const id = match[1];
        if (ids.has(id)) {
          duplicateIds.add(id);
        } else {
          ids.add(id);
        }
      }
      if (duplicateIds.size > 0) {
        new import_obsidian.Notice(`Duplicate QJSON IDs found: ${Array.from(duplicateIds).join(", ")}`);
      }
      const uniqueCount = ids.size;
      if (uniqueCount > 0) {
        this.statusBarItemEl.setText(`${uniqueCount} qjson`);
      } else {
        this.statusBarItemEl.setText("");
      }
    } catch (error) {
      console.error("Error counting QJSON blocks:", error);
      this.statusBarItemEl.setText("");
    }
  }
  onunload() {
    this.qjsonBlockCount = 0;
    this.statusBarItemEl.setText("");
  }
};
function formatElement(parent, format, json, text) {
  if (!text) {
    if (format.field) {
      const textJson = json[format.field];
      if (Array.isArray(textJson)) {
        text = textJson.map((j) => formatOutput(j));
      } else {
        text = formatOutput(textJson);
      }
    } else {
      text = formatString(format.template, json);
    }
  }
  let el;
  if (format.bold) {
    el = parent.createEl("b");
  } else {
    el = parent;
  }
  if (Array.isArray(text)) {
    let idx = 0;
    for (let t of text) {
      if (format.link) {
        el.createEl("a", { text: t, href: json[format.field2][idx] });
      } else {
        el.appendText(t);
      }
      if (idx < text.length - 1) {
        if (format.comma) {
          el.appendText(", ");
        } else if (format.br) {
          el.createEl("br");
        } else {
          el.appendText(" ");
        }
      }
      idx++;
    }
  } else {
    if (format.link) {
      el.createEl("a", { text, href: json[format.field2] });
    } else {
      el.appendText(text);
    }
  }
}


/* nosourcemap */